#!/usr/bin/env perl

use warnings;
use strict;

use Cwd;
use File::Basename;


use Config::Tiny;
use Data::Dumper;
use DateTime::Format::Strptime;

use WebService::Dropbox;

# Configures the output based on if color is preferred
my $color = 1;
if ($color) {
    our $ADD_COLOR = "\x1b[0;92m";    # Green
    our $MODIFY_COLOR = "\x1b[0;93m"; # Orange
    our $DELETE_COLOR = "\x1b[0;91m"; # Red
    our $CHECK_COLOR = "\x1b[0;94m";  # Blue

    our $COLOR_END = "\x1b[0m";
}
else {
    our $ADD_COLOR = "";
    our $MODIFY_COLOR = "";
    our $DELETE_COLOR = "";

    our $COLOR_END = "";
}

# Server time format parser
our $timeparser = DateTime::Format::Strptime->new(pattern => '%A, %d %B %Y %T %z');


#
# Returns a Dropbox interface based on the .mb.cnf configuration.
#
sub get_dropbox{
    # Load configuration
    my $config = Config::Tiny->read('.mb.cnf');
    my $config_hash = $config->{_};

    my $KEY = $config_hash->{KEY};
    my $SECRET = $config_hash->{SECRET};
    my $access_token = $config_hash->{ACCESS_TOKEN};
    my $access_secret = $config_hash->{ACCESS_SECRET};


    my $dropbox = WebService::Dropbox->new({key => $KEY, # App Key
                                            secret => $SECRET # App Secret
                                           });

    if (!$access_token or !$access_secret) {
        my $url = $dropbox->login or die $dropbox->error;
        warn "Please Access URL and press Enter: $url";
        <STDIN>;
        $dropbox->auth or die $dropbox->error;
        warn "access_token: " . $dropbox->access_token;
        warn "access_secret: " . $dropbox->access_secret;
    } else {
        $dropbox->access_token($access_token);
        $dropbox->access_secret($access_secret);
    }

    return $dropbox;
}


#
# Pulls a directory or file from the Dropbox account.
#
# @param Path to pull (defaults to '/').
# @param Dropbox interface.
# @param Path metadata (not needed).
#
sub pull{

    # Load color configuration
    our $ADD_COLOR;
    our $MODIFY_COLOR;
    our $DEL_COLOR;
    our $CHECK_COLOR;

    our $COLOR_END;

    # Load parameters
    my $path = shift || '/';
    if ($path eq '') {
        $path = '/';
    }

    my $dropbox = shift || get_dropbox();
    my $data = shift || $dropbox->metadata($path) or die "Error requesting $path data";

    my $rel_path = basename($path);
    my $is_dir = $data->{is_dir};

    # If is a file
    if (!$is_dir) {

        # Compare the modification dates, download it only if it's needed.
        my $fmodtime = $timeparser->parse_datetime($data->{modified})->epoch;
        my $localmodtime = (stat $rel_path)[9] || -1;

        if ($fmodtime > $localmodtime) {

            my $status;
            if ($localmodtime == -1) {
                $status = $ADD_COLOR . "A" . $COLOR_END;
            }
            else {
                $status = $MODIFY_COLOR . "M" . $COLOR_END;
            }
            print "$status Downloading $path [".$data->{size}."]...\n";

            my $fh_get = IO::File->new($rel_path, '>');
            $dropbox->files($path, $fh_get) or die $dropbox->error;
            $fh_get->close;
            utime($fmodtime, $fmodtime, $rel_path);
        }
    }

    # If is a directory
    else {
        print "$CHECK_COLOR#$COLOR_END Checking $path...\n";

        # Create the directory
        if ($rel_path ne '/') {
            mkdir($rel_path);
            chdir($rel_path) or die "Error entering $rel_path";
        }

        # Load metadata
        if (!$data->{contents}) {
            $data = $dropbox->metadata($path);
        }

        # Repeat for each directory entry
        my $contents = $data->{contents};
        foreach (@$contents) {
            if (basename($_->{path}) ne '.metadata') {
                pull($_->{path}, $dropbox, $_);
            }
        }

        if ($rel_path ne '/') {
            chdir("..") or die 'Error returning';
        }
    }
}


#
# Shows the command line options
#
sub print_usage{
    print "minibox (pull|push) [(file|folder) [(file|folder) [...]]]\n"
}


# Manage the command line parameters
if ($#ARGV < 0) {
    print_usage();
    exit 0;
}

if ($ARGV[0] eq "pull") {
    if ($#ARGV == 0) {
        push(@ARGV, '/');
    }

    for(my $i = 1; $i <= $#ARGV; $i++) {
        pull($ARGV[$i]);
    }
}
