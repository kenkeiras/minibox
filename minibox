#!/usr/bin/env perl

use warnings;
use strict;

use Cwd;
use File::Basename;


use Config::Tiny;
use Data::Dumper;
use DateTime::Format::Strptime;

use WebService::Dropbox;

my $color = 1;
if ($color) {
    our $ADD_COLOR = "\x1b[0;92m";
    our $MODIFY_COLOR = "\x1b[0;93m";
    our $DELETE_COLOR = "\x1b[0;91m";
    our $CHECK_COLOR = "\x1b[0;94m";

    our $COLOR_END = "\x1b[0m";
}
else {
    our $ADD_COLOR = "";
    our $MODIFY_COLOR = "";
    our $DELETE_COLOR = "";

    our $COLOR_END = "";
}


our $timeparser = DateTime::Format::Strptime->new(pattern => '%A, %d %B %Y %T %z');

sub get_dropbox{
    # Load configuration
    my $config = Config::Tiny->read('.mb.cnf');
    my $config_hash = $config->{_};

    my $KEY = $config_hash->{KEY};
    my $SECRET = $config_hash->{SECRET};
    my $access_token = $config_hash->{ACCESS_TOKEN};
    my $access_secret = $config_hash->{ACCESS_SECRET};

    # Connect
    my $dropbox = WebService::Dropbox->new({key => $KEY, # App Key
                                            secret => $SECRET # App Secret
                                           });

    if (!$access_token or !$access_secret) {
        my $url = $dropbox->login or die $dropbox->error;
        warn "Please Access URL and press Enter: $url";
        <STDIN>;
        $dropbox->auth or die $dropbox->error;
        warn "access_token: " . $dropbox->access_token;
        warn "access_secret: " . $dropbox->access_secret;
    } else {
        $dropbox->access_token($access_token);
        $dropbox->access_secret($access_secret);
    }

    return $dropbox;
}


sub pull{
    our $ADD_COLOR;
    our $MODIFY_COLOR;
    our $DEL_COLOR;
    our $CHECK_COLOR;

    our $COLOR_END;

    my $path = shift || '/';
    if ($path eq '') {
        $path = '/';
    }

    my $dropbox = shift || get_dropbox();

    my $data = shift || $dropbox->metadata($path) or die "Error requesting $path data";

    my $rel_path = basename($path);
    my $is_dir = $data->{is_dir};

    if (!$is_dir) {

        my $fmodtime = $timeparser->parse_datetime($data->{modified})->epoch;
        my $localmodtime = (stat $rel_path)[9] || -1;

        if ($fmodtime > $localmodtime) {

            my $status;
            if ($localmodtime == -1) {
                $status = $ADD_COLOR . "A" . $COLOR_END;
            }
            else {
                $status = $MODIFY_COLOR . "M" . $COLOR_END;
            }
            print "$status Downloading $path [".$data->{size}."]...\n";

            my $fh_get = IO::File->new($rel_path, '>');
            $dropbox->files($path, $fh_get) or die $dropbox->error;
            $fh_get->close;
            utime($fmodtime, $fmodtime, $rel_path);
        }
    }
    else {
        print "$CHECK_COLOR#$COLOR_END Checking $path...\n";
        if ($rel_path ne '/') {
            mkdir($rel_path);
            chdir($rel_path) or die "Error entering $rel_path";
        }

        if (!$data->{contents}) {
            $data = $dropbox->metadata($path);
        }
        my $contents = $data->{contents};
        foreach (@$contents) {
            if (basename($_->{path}) ne '.metadata') {
                pull($_->{path}, $dropbox, $_);
            }
        }
        if ($rel_path ne '/') {
            chdir("..") or die 'Error returning';
        }
    }
}


sub print_usage{
    print "minibox (pull|push) [(file|folder) [(file|folder) [...]]]\n"
}


if ($#ARGV < 0) {
    print_usage();
    exit 0;
}

if ($ARGV[0] eq "pull") {
    if ($#ARGV == 0) {
        push(@ARGV, '/');
    }

    for(my $i = 1; $i <= $#ARGV; $i++) {
        pull($ARGV[$i]);
    }
}
